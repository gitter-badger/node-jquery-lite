// Generated by CoffeeScript 1.8.0
(function() {
  var __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  $.extend = function(target, object) {
    var k, t, v;
    t = target;
    for (k in object) {
      v = object[k];
      t[k] = v;
    }
    return t;
  };

  $.type = function(param) {
    var p, t;
    switch (t = typeof (p = param)) {
      case 'object':
        if (p) {
          if (p.fill) {
            return 'buffer';
          }
          if (toString.call(p) === '[object Array]') {
            return 'array';
          }
          return 'object';
        } else {
          if (p === null) {
            return 'null';
          }
          return 'undefined';
        }
        break;
      case 'number':
        if (p !== +p) {
          return 'NaN';
        }
        return t;
      default:
        return t;
    }
  };

  $.param = (require('querystring')).stringify;

  $.trim = function(str) {
    return str.toString().replace(/(^\s*)|(\s*$)/g, '');
  };

  $.now = Date.now;

  $.Callbacks = function(flags) {
    var r;
    return r = {
      status: {
        fired: false
      },
      list: [],
      add: function() {
        var fn, p, _i, _len;
        p = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = p.length; _i < _len; _i++) {
          fn = p[_i];
          r.list.push(fn);
        }
        return r;
      },
      remove: function(fn) {
        var f, i, _i, _len, _ref;
        _ref = r.list;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          f = _ref[i];
          if (!(f === fn)) {
            continue;
          }
          r.list.splice(i, 1);
          break;
        }
        return r;
      },
      has: function(fn) {
        if (__indexOf.call(r.list, fn) >= 0) {
          return true;
        } else {
          return false;
        }
      },
      empty: function() {
        r.list = [];
        return r;
      },
      fire: function() {
        var f, p, _i, _len, _ref;
        p = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _ref = r.list;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          f = _ref[_i];
          if (typeof f === "function") {
            f.apply(null, p);
          }
        }
        r.status.fired = true;
        return r;
      },
      fired: function() {
        return r.status.fired;
      }
    };
  };

}).call(this);
